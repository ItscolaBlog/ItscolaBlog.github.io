<!DOCTYPE html>
<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Java and C# developer.">
    <meta name="Author" content="White_cola">
    <meta name="keywords" content="白可乐的博客,White_cola Blog,white_cola,white_cola mcbbs">
    <link rel="stylesheet" href=https://itscola.github.io/css/syntax.css>
    <link rel="stylesheet" href=https://itscola.github.io/css/style.css>
    <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
    <title>White_cola Blog</title>
  </head><body><aside id="sidenav">
    <header>
    
        <a href=https://itscola.github.io/><img src="https://itscola.github.io/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://itscola.github.io/>
        
            White_cola Blog
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/"
                
            >
                <i class="fas fa-home fa-sm"></i>
                <span>主页</span>
            </a>
        
            		
            <a href="/blog/"
                
            >
                <i class="blog"></i>
                <span>全部文章</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="tags"></i>
                <span>标签</span>
            </a>
        
            		
            <a href="https://github.com/itscola"
                
                    target="_blank"
                
            >
                <i class="github"></i>
                <span>github</span>
            </a>
        
            		
            <a href="/tags/machine-learning/"
                
            >
                <i class="MachineLearning"></i>
                <span>机器学习</span>
            </a>
        
            		
            <a href="/tags/computersystemframework/"
                
            >
                <i class="ComputerSystemFramework"></i>
                <span>计算机系统结构</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">
    
    <h1 id="title">Java IO 基础知识 - 温故而知新</h1>
    
      
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一-数据流的概念">一 数据流的概念</a>
      <ul>
        <li><a href="#1-输入数据流-inputstream">1. 输入数据流 (InputStream)</a></li>
        <li><a href="#2-输出数据流outputstream">2. 输出数据流(OutputStream)</a></li>
      </ul>
    </li>
    <li><a href="#二-常用字节流">二 常用字节流</a>
      <ul>
        <li><a href="#1-文件数据流fileoutputstream--fileinputstream">1. 文件数据流(FileOutputStream &amp; FileInputStream)</a></li>
        <li><a href="#2-过滤器数据流">2. 过滤器数据流</a></li>
        <li><a href="#21-缓冲区数据流bufferedinputstream--bufferedoutputstream">2.1 缓冲区数据流（BufferedInputStream &amp; BufferedOutputStream）</a></li>
        <li><a href="#22-数据数据流">2.2 数据数据流</a></li>
      </ul>
    </li>
    <li><a href="#三-常用字符流reader--writer">三 常用字符流(Reader / Writer)</a>
      <ul>
        <li><a href="#1-读写者">1. 读写者</a></li>
        <li><a href="#11-printwriter">1.1 PrintWriter</a></li>
        <li><a href="#2-缓冲区读写者-buffered">2. 缓冲区读写者 (Buffered)</a></li>
      </ul>
    </li>
    <li><a href="#三-文件-file">三 文件 (File)</a>
      <ul>
        <li><a href="#1-文件名">1. 文件名</a></li>
        <li><a href="#2-文件测试">2. 文件测试</a></li>
        <li><a href="#3-文件信息">3. 文件信息</a></li>
        <li><a href="#4-目录">4. 目录</a></li>
      </ul>
    </li>
    <li><a href="#四-随机访问randomaccessfile">四 随机访问（RandomAccessFile）</a></li>
  </ul>
</nav>
    <hr>
<h1 id="java-io-基础知识">Java IO 基础知识</h1>
<p>在这里我们会讲解一些必备的基础知识，以便使用。<strong>会把最实用的内容挑出来，方便理解。如果想看 Java I/O 的所有知识，网上的文章已经很多了</strong>。 <u>这篇文章追求的是简单易懂</u>。</p>
<p>注意，看之前，强烈建议先理解，<u>装饰设计模式</u>。它能让你懂得 缓冲流 转换流 的实现原理。</p>
<h2 id="一-数据流的概念">一 数据流的概念</h2>
<p>输入文字，读取文件数据，向文件写入数据。这些 输入/输出 源头（数据）在java中都称为流。输入和输出的数据就被称为数据流，它是有顺序的一组 byte 集合。</p>
<p>输入输出 的方式有 输入流，输出流。  <br>
输入流只能输入，输出流只能输出。读取数据时，将数据源要与数据流连接。(后面会讲。)</p>
<blockquote>
<p>可以把流想象成一堆液体，液体里就是我们要的数据。如果我们要运输液体，那我们必须要弄“管道”用于传输液体。管道的不同，会有不同到特性。（这个比喻不恰当的地方在于，用管道运输流时，流是有顺序的进入。但这个比喻更容易理解。）</p>
</blockquote>
<p>java 的流操作在 java.io 包中，java.io  中分为两类流，字节流和字符流。JDK 字符流的加入晚于字节流，用于更好的处理字符。提供了一些字符操作的参数等。</p>
<blockquote>
<p><u>(根据运输“管道”的不通，可以分出 字节流 和 字符流。它们的运输方式不一样。)</u></p>
</blockquote>
<p><img src="/JavaIO/1.png" alt="图片"></p>
<h3 id="1-输入数据流-inputstream">1. 输入数据流 (InputStream)</h3>
<p>输入数据流为只能读取，不能写入的数据流。<br>
<u>所有字节流中的输入数据流，都继承自InputStream 抽象类，实现了它的方法，字段。 <br>
</u></p>
<p>它有几个常用方法：  <br>
int read(); 从输入流读取一个字节的数据。   <br>
int read(byte[] b); 读取 b.lenght 个字节，并放入数组中。  <br>
int read(byte[] b, int off, int len);  读取 len 个字节，并放入 b ，从数组下标 off 开始。</p>
<p>这些 read 方法，会返回 0 - 255 int类型返回值，当读取结束时， 会返回 -1 。</p>
<blockquote>
<p>可以看出输入字节流是以 byte 为单位，一个一个将流运输的。 当然，字节流的输出也是这样的。</p>
</blockquote>
<p>void close(); 关闭流，释放资源。(实际上 Java 的 GC 会在之后自动关闭，但是为了安全稳定可读，最好还是手动关闭流。)</p>
<p>int available(); 返回可读的字节数量。</p>
<p>long skip(long n); 跳过 n 个字节。</p>
<p>boolean markSupported(); 判断流是否支持标记流。</p>
<p>void mark(int readLimit); 标记读取的位置。</p>
<p>void reset(); 重置读取位置，回到上一个标记点。</p>
<h3 id="2-输出数据流outputstream">2. 输出数据流(OutputStream)</h3>
<p>输出数据流为只能写入，不能读取数据流。<br>
<u>所有字节流中的输出数据流，都继承自OutputStream 抽象类，实现了它的方法，字段。 <br>
</u></p>
<p>它有几个常用方法：  <br>
void write(int b) 将字节 i 写入到数据流中，只输出参数的最低 8 位。  <br>
void write(byte b[]) 将字节数组 b 全部写入到数据流中。 <br>
void write(byte b[],int off,int len) 将字节数组 b 从 off 开始，写 len 长度字节。</p>
<p>void close() 关闭输出流。</p>
<p>void flush() 刷新输出流，写出缓冲的字节。</p>
<h2 id="二-常用字节流">二 常用字节流</h2>
<p>字节流是继承了 InputStream 和 OutputStream 两个抽象类的 输入流和输出流。 <br>
<u>它在输入时/读取时，是一个字节一个字节的读取。</u></p>
<h3 id="1-文件数据流fileoutputstream--fileinputstream">1. 文件数据流(FileOutputStream &amp; FileInputStream)</h3>
<p>文件数据流包括 FileInputStream 和 FileOutputStream ，一个继承了  InputStream  (输入流) ， 一个继承了 OutputStream (输出流)。</p>
<p>主要用于文件的输入和输出。数据源为文件。 并且不支持 mark 与 reset 方法。</p>
<p>先来看输入流：</p>
<p>我们可以通过 new FileInputStream(String path) 或 new FileInputStream(File file) 来指定我们要读取的文件。</p>
<pre><code>public static byte[] readFile(File file){
        if(!file.isFile()){
           return null;
        }
        try(FileInputStream fis = new FileInputStream(file){
            byte[] data = new byte[fis.available()];
            fis.read(data);
            return data;
        }catch (IOException e){
            return new byte[0];
        }

    }
</code></pre><p>当找不到指定文件时，会出现 FileNotFoundException 异常 (上方 demo 提前判断过了)。 它属于 IOException，可以捕捉声明 IOException。</p>
<p>注意，将创建输入流的代码写在 try 里，会自动进行 close。 不写在 try 里要记得写。</p>
<p>再来看输出流：</p>
<p>同样的，我们可以通过 new FileOutputStream(String path) 或 new FileOutputStream(File file) 来指定我们要读取的文件。  以及我们可以在后面加个 boolean append 参数来决定是否要覆盖文件。 例如 <code>OutputStream ops = new FileOutputStream(file,append); </code></p>
<pre><code>public static void writeFile(byte[] data,File file,boolean append) throws IOException{
        if(!file.getParentFile().exists()){
            file.getParentFile().mkdirs();
        }

        if(!file.isFile()){
            file.createNewFile();
        }

        try(OutputStream ops = new FileOutputStream(file,append)){
          
            ops.write(data);
            ops.flush();
        }

    }

</code></pre><p>当然，上方的代码我们还可以这样写 <code>ops.write(String str)</code> 来写入字符串</p>
<h3 id="2-过滤器数据流">2. 过滤器数据流</h3>
<p>它的实现采用了 装饰设计模式（包装模式），有兴趣的话可以搜索看下，还是挺实用的。</p>
<p>顾名思义，过滤器。 就是给 数据流 后面加个过滤器，然后再通过 过滤器 进行 输入/输出 操作。过滤器会在中间起到特殊处理作用。</p>
<h3 id="21-缓冲区数据流bufferedinputstream--bufferedoutputstream">2.1 缓冲区数据流（BufferedInputStream &amp; BufferedOutputStream）</h3>
<p>很多人对数据流很熟悉，但是缓冲区就弄不清了。</p>
<p>缓冲区也是过滤器的一种。</p>
<p>它其实就是在原本 数据输入/输出流 后加了个缓冲区。 缓冲区可以让我们一下得到一堆数据，然后再传输。</p>
<blockquote>
<p>可以这样理解，我们要搬运一大堆东西，一下搬好几个总比一下搬一个要快上不少。</p>
</blockquote>
<p>这样做还有好处就是降低不同设备之间的 I/O 操作速度差异，提高效率。</p>
<p>我们可以这样给 输入流/输出流 添加缓冲区。</p>
<pre><code>FileInputStream fis = new FileInputStream(“file“);
InputStream bis = new BufferedInputStream(fis);

FileOutputStream fos = new FileOutputStream(“file“);
OutputStream bos = new BufferedOutputStream(fos);

// 可以简化 例如
InputStream bis2 = new BufferedInputStream(new FileInputStream(“file“));

// 也可以自定义缓冲区大小

FileInputStream fis3 = new FileInputStream(“file“);
InputStream bis3 = new BufferedInputStream(fis,2048);

FileOutputStream fos3 = new FileOutputStream(“file“);
OutputStream bos3 = new BufferedOutputStream(fos,1024);

</code></pre><p>在 close 之前，调用flush 方法，将缓冲区内残留的数据流强制输出。</p>
<blockquote>
<p>因为最后剩余的数据流，不一定能塞满缓冲区。 所以会有剩余数据流。</p>
</blockquote>
<h3 id="22-数据数据流">2.2 数据数据流</h3>
<p>这个数据流，并非像前面的一样，只能处理字节或字节数组。它允许通过数据流读写各种 Java 基本类型。</p>
<p>创建方式也是经典 装饰设计模式。</p>
<pre><code>DataInputStream dis = new DataInputStream(InputStream is);

DataOutputStream dos = new DataOutputStream(OutputStream is);
</code></pre><p>然后是它的各种方法：</p>
<p>byte readByte();  <br>
short readShort();
int readInt();<br>
long readLong(); <br>
float readFloat();   <br>
double readDouble(); <br>
boolean readBoolean(); <br>
String readUTF();  <br>
char readChar();</p>
<p>对应的还有Write方法</p>
<p>void writeByte(int abyte);   <br>
void writeLong(long along);</p>
<p>&hellip;&hellip;</p>
<p>DataInputStream 和 DataOutputStream 会成对出现。 一般是写完 之后会 读。 它们也可以读写字符串，但是为了不乱码，不要用它们来读写字符串。 要用之后会讲的 Reader / Writer。</p>
<h2 id="三-常用字符流reader--writer">三 常用字符流(Reader / Writer)</h2>
<p>类似于 OutputStream 和 InputStream， 字符流是 Writer 和 Reader 两个抽象类。 <br>
它们的方法换成了字符或字符数组。</p>
<h3 id="1-读写者">1. 读写者</h3>
<p>有了 Reader 和 Writer ，可以实现不同平台数据流中的数据转换。 Java 用 Unicode 来表示字符串以及字符，用 2 个字节来表示一个字符。 而ASCII 这样的字符集，用一个字节(8bit) 表示一个字符。 为了实现不同平台转换，JDK 出现了 字符流。</p>
<p>可以通过 InputStreamReader 和 OutputStreamWriter 来进行，字节流与字符流之间的转换，也就是 转换流。    它们也继承了 Reader 和 Writer。 典型的 装饰模式。 通过转换，Java 用 Unicode 字符集 ，也实现了平台无关性。</p>
<p>构造方法有:  <br>
InputStreamReader(InputStream is);   <br>
InputStreamReader(InputStream is , String encode); 指定编码</p>
<p>OutputStreamWriter(OutputStream out);
OutputStreamWriter(OutputStream out, String encode);  指定编码</p>
<pre><code>InputStreamReader dis = new InputStreamReader(new FileInputStream(“file“));
</code></pre><p>Reader的方法有：</p>
<p>int read();  <br>
int read(char[] cbuf);    <br>
int read(char[] cbuf, int off, int len);  <br>
void close;  <br>
boolean ready();   <br>
void rest();   <br>
long skip(long n);
void mark(intreadAheadLimit);  <br>
boolean markSupported();</p>
<ul>
<li></li>
</ul>
<p>Writer的方法有：</p>
<p>void write(int c);  <br>
void write(char[] cbuf);   <br>
void write(char[] cbuf , int off, int len);   <br>
void write(String str);  <br>
void write(String str, int off , int len);  <br>
void flush();  <br>
void close();</p>
<blockquote>
<p>另外，还有 FileReader , 与 FileWriter 比较常用，它们继承自 InputStreamReader 和 OutputStreamWriter（之后会补上，写完这篇文章要去忙学业了。） <a href="https://www.runoob.com/java/java-filereader.html">https://www.runoob.com/java/java-filereader.html</a> <br>
<a href="https://www.runoob.com/java/java-filewriter.html">https://www.runoob.com/java/java-filewriter.html</a></p>
</blockquote>
<h3 id="11-printwriter">1.1 PrintWriter</h3>
<p>PrintWriter 是个很实用的东西，它的使用符合 平常的输出。 System.out.println(); 还有 System.out.print();</p>
<p>它提供 print() 和 println() , 用于写入字符。  <br>
比如</p>
<pre><code>PrintWriter pwt = PrintWriter(new FileWriter(“file.tex“));
ptw.println(“ Apple“);
ptw.print(“Google“);
ptw.print(“|Microsoft“);
ptw.close();
</code></pre><p>file.txt 文件里的内容就是</p>
<pre><code> Apple
Google|Microsoft
</code></pre><h3 id="2-缓冲区读写者-buffered">2. 缓冲区读写者 (Buffered)</h3>
<p>Reader 和 Writer 也是，如果要读写的内容很多，那么也可以用缓冲区提高效率。也就是 BufferedReader 与 BufferedWriter。用法和 BufferedInputStream ，BufferedOutputStream 类似。</p>
<p>它们除了从 Reader 和 Writer 继承来的方法，还有 String readLine();  这是 BufferedReader 用来获取整行字符的方法，结束标志位 ‘\n‘ ‘\r‘，没有字符时将返回 null。对应的，BufferWriter 有 void newLine(); 方法，用来在输出流中写入新行。</p>
<p>BufferReader 可以放在 Reader 后面。    <br>
BufferWriter 可以放在 Writer 后面。   <br>
在关闭（close）时，记得使用 flush(); 清空缓冲区剩余内容。</p>
<p>比如：</p>
<pre><code>BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(“file“)));
</code></pre><h2 id="三-文件-file">三 文件 (File)</h2>
<p>java 提供了 File 类，以便我们更方便的操纵文件，创建文件。   <br>
比如，我可以看文件是否存在，能不能写入，路径是什么，文件大小多大，创建目录 &hellip;&hellip;</p>
<p>下面看下构造方法：  <br>
File(String path); 指定路径，创建一个 FIle 实例。  <br>
File(String parent, String child);   根据 parent 和 child 路径创建一个 File。    <br>
File(File dir,String fileName);      根据 File 实列创建一个新的 file。</p>
<p>通常还是用第一个构造方法来创建 File。</p>
<pre><code>File file = new File(“file.txt“);

file = new File(“./dir/file.txt“);
</code></pre><p>它还有以下这些常用方法。</p>
<h3 id="1-文件名">1. 文件名</h3>
<p>String getName();     获得文件名。  <br>
String getPath();      获得文件路径。 <br>
String getParent();     获得文件父目录。 <br>
String getAbsolutePath();     获得绝对路径。
boolean renameTo(File newName);    改名，成功返回 true，否则 false。</p>
<h3 id="2-文件测试">2. 文件测试</h3>
<p>boolean exists();   文件是否存在。<br>
boolean isFile();   文件对象是否是文件。  <br>
boolean canWrite();  文件是否可写。 <br>
boolean canRead();   文件是否可读。  <br>
bolean isDirector(); 是否是目录。  <br>
bolean isAbsolute();   是否是绝对路径。</p>
<h3 id="3-文件信息">3. 文件信息</h3>
<p>long lastModified();  获取文件三次修改时间戳。   <br>
long length();   获取文件长度。   <br>
boolean delete();   删除对象指定的文件，成功返回 true ，失败返回 false。</p>
<h3 id="4-目录">4. 目录</h3>
<p>boolean mkdir();    创建一个新目录。     <br>
boolean mkdirs();   创建多个层次的新目录。  <br>
String[] list();    列出目录下的文件名。</p>
<h2 id="四-随机访问randomaccessfile">四 随机访问（RandomAccessFile）</h2>
<p>通过 RandomAccessFile 可以实现各种换不同的位置进行读写。 是在开发中很常用的一个类。</p>
<p>可以通过两种方式创建对象。    <br>
new RandomAccessFile(String path, String mode);     <br>
new RandomAccessFile(File file, String mode);</p>
<p>mode 可以填 “r“ , “w“ , “rw“。分别表示 只读，只写，读写。</p>
<p>RandomAccessFile 可以通过指针来决定位置，这就类似于编辑文档时会闪的 “｜”，表示位置。 它可以通过以下几种方法来操作指针。</p>
<p>long getFilePointer() ; 获取文件指针位置。    <br>
void seek(long pos);  设置指针位置，0 代表文件的开始。   <br>
long lenght();    返回文件的长度，在指针上就是 lenght()。</p>
<p>移动好指针位置后，就可以使用 write 和 read 来进行操作了。</p>

    
    <div class="nav-next-prev">
        <div class="nav-prev">
            
                <a href="https://itscola.github.io/blog/ijava/projector-idea-ide/"><i class="fas fa-chevron-left"></i></a>
            
        </div>
        <a class="nav-top" href="#">top</i></a>
        <div class="nav-next">
            
                <a href="https://itscola.github.io/blog/javaui/java-ui-develope-1/"><i class="fas fa-chevron-right"></i></a>
            
        </div>
    </div>
    

            </div><footer>
<div class="footer-content">

  <div class="contact-info">
      
      
  </div>


<p class="copyright meta">失落和喜悦不断交缠，执着的一切充满挑战。
 Blog Powered by Hugo.</p>

</div>
</footer></main>
    </body>
    <script src=https://itscola.github.io/js/navbutton.js></script>
</html>
